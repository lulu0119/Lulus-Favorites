# Rust 宏（Macro）

## 简介

-   **宏标识**:`!` 符号用于区分宏调用与普通函数调用，提示开发者宏在编译时具有特殊行为，能生成或修改代码。
-   **用途**：宏允许编译时代码生成、逻辑控制、类型无关操作等，提供了超越函数的灵活性。

## `println!` 宏

-   **功能**：格式化输出并自动换行。
-   **用法**：
    ```Rust
    println!("Hello, world!");
    ```
-   **编译时处理**：编译器将宏调用替换为具体的输出代码。

## 宏与函数的区别

-   **函数**:
    -   运行时执行。
    -   遵循类型系统和作用域规则。
    -   对参数类型有严格要求。
    -   返回值。
-   **宏**:
    -   编译时操作。
    -   可修改代码结构，不受类型系统限制。
    -   宏调用在编译阶段展开为代码片段。
    -   支持条件编译等高级功能。

## 宏定义示例

```Rust
macro_rules! my_macro {
  ($input:expr) => {
    // 展开逻辑
    println!("Input value is: {}", $input);
  };
}

fn main() {
  my_macro!(42); // 调用宏，编译时展开为 println!("Input value is: {}", 42);
}
```

## 宏在调试中的应用

-   **直接在函数中使用** `println!`：常规调试手段。
-   **自定义调试宏**：根据条件控制调试输出。

```Rust
macro_rules! debug_println {
  ($($arg:tt)*) => {
    if cfg!(debug_assertions) {
      println!($($arg)*);
    }
  };
}
```

## 使用场景

-   **编译时计算与代码生成**：如重复结构体定义。
-   **元编程**：根据类型自动生成实现。
-   **令牌级操作**：处理代码的最小单位。
-   **条件编译**：根据编译标志控制代码。
-   **增强泛型性**：超越类型参数的泛化。

## `return` 关键字

-   Rust 支持 `return`，但在函数体的最后一个表达式可省略，其值自动作为返回值。
