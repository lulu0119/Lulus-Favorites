# 普通对象 vs Proxy 对象与 Getter/Setter 的对比分析

## ECMA 规范 10.1.8 节：普通对象的属性访问机制

普通对象的属性访问遵循 `OrdinaryGet` 规则，这一过程描述了属性查找和获取的流程。当试图获取一个属性时，系统首先在当前对象上查找该属性，若未找到，则沿着原型链递归查找，直至到达原型链的末端。如果找到的是数据描述符，直接返回其值；若是访问器描述符，则调用其 `[[Get]]` 方法。这一过程确保了属性访问的连贯性和一致性。

## ECMA 规范 10.5.8 节：Proxy 对象的属性访问机制

`Proxy` 对象的属性访问通过 `[[Get]]` 方法实现，允许开发者通过 `handler` 对象中的 `get` 方法自定义属性获取行为。如果 `handler` 中定义了 get 方法，该方法将在属性访问时被调用，接收目标对象、属性名和接收者作为参数。若未定义 `get` 方法，则按照普通对象的方式从目标对象获取属性。`Proxy` 的 `[[Get]]` 方法还包含对属性完整性的检查，确保不可配置的属性值不会被非法改变。

## 普通对象中的 getter 和 setter 与 Proxy 的对比

-   **`getter` 和 `setter`**：在普通对象中定义，用于控制特定属性的读取和写入行为，适用于单个属性的封装和控制，提供直观和简洁的接口，但不支持对非属性操作的拦截。
-   **`Proxy`**：提供更广泛的控制能力，能够拦截并自定义几乎所有 JavaScript 操作，不仅限于属性访问，还能用于方法调用、实例创建等，适合更复杂的数据处理逻辑和高级应用场景。

选择使用 `getter` 和 `setter` 还是 `Proxy` 取决于具体的需求和场景。`getter` 和 `setter` 更适合简单的属性封装和控制，而 `Proxy` 则为需要更广泛控制和复杂逻辑的场景提供了强大的工具。理解这些机制的差异有助于开发人员更有效地利用 JavaScript 特性，构建健壮和灵活的应用程序。

## Vue 中的 ref() 和 reactive() 的区别

在 Vue 中，`ref()` 和 `reactive()` 是用于创建响应式数据的两种方法。

-   `ref()` 是 Vue 中创建响应式引用的一种方式。它返回一个带有 `.value` 属性的对象，该对象内部使用了 `Getter` 和 `Setter` 来实现数据的响应式更新

-   `reactive()` 是 Vue 中另一种创建响应式对象的方式，它利用了 ES6 的 `Proxy` 对象来实现。`reactive()` 接收一个普通对象作为参数，并返回一个响应式的版本。
